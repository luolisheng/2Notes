### 2017-04-14
1. 自我介绍
2. runtime的运用
	1. [link1](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)
3. runloop
	1. 自动释放池、延迟回调、触摸事件、屏幕刷新等基于runloop实现。
	2. 线程和runloop是一一对应的，其关系是保存在一个全局的字典里，一个线程不一定只有一个runloop，runloop可以嵌套。
	3. 线程刚创建时没有runloop，如果不主动创建一直就不会有。
	4. runloop的创建发生在第一次获取时，销毁发生在线程结束时。
	5. [link1](https://www.zybuluo.com/qidiandasheng/note/346387)
	6. [link2](http://blog.ibireme.com/2015/05/18/runloop/)
	7. [link3](http://www.jianshu.com/p/4d5b6fc33519)
4. 事件传递及响应
	1. 事件分三类：触摸事件、加速计事件、远程控制事件。
	2. 只有继承自UIResponder的对象才能接收并响应事件。
	3. 触摸事件产生和传递。
		1. 一个硬件事件发生之后，系统将该事件加入到UIApplication管理的事件队列。
			1. IOKit.framework生成一个IOHIDEvent事件并由SpringBoard接收。
			2. 随后用 mach port 转发给需要的App进程。
			3. runloop调用_UIApplicationHandleEventQueue()进行分发。
			4. _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发。
		2. UIApplication从队列中取出最前面的事件并分发给keywindow处理。
		3. keywindow会在视图层次结构中找到最合适的视图来处理触摸事件。
			1. 先查看自己能否接收触摸事件，自己不接收则返回nil。
			2. 再检查触摸点是否在自己身上，不在自己身上则返回nil。
			3. 然后遍历子控件，重复1、2步骤。
			4. 最后没有合适的子控件就是自己最合适处理。
		4. 找到合适的视图之后就会调用视图控件的touches方法来做事件处理。
		5. touches方法的默认做法是将事件顺着响应者链向上传递。
			1. 默认调用[super touch...]，调用上一个响应者的touch方法。
	4. 不接受触摸事件的几种情况。
		1. 不接收交互userInteractionEnabled = NO。
		2. 隐藏 hidden=YES。
		3. 透明。
	5. 响应者链的事件传递过程
		1. 当前view是控制器的view，控制器就是上一个响应者；当前这个view不是控制器的view，那么父控件就是上一个响应者。
		2. 最顶层视图也不能处理接收到的事件则传递给window对象处理。
		3. window对象也不处理则传递给UIApplication对象。
		4. UIApplication也不能处理消息则将其丢弃。
	6. [link1](http://www.jianshu.com/p/82024d85c529)
5. 浅拷贝和深拷贝
	1. [link1](https://www.zybuluo.com/MicroCai/note/50592)
	2. [link2](http://blog.csdn.net/qq_18425655/article/details/51325921)
6. 多线程运用／GCD队列／实现线程依赖
7. 数组和链表
8. 对象在内存中的位置
9. 消息转发机制
	1. [link1](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)
10. Autorelease Pool工作原理和使用场景、引用计数为0时什么时候释放对象
	1. [link1](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)
	2. [link2](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/#jtss-tsina)
	3. [link3](http://yangchao0033.github.io/blog/2015/12/31/guan-yu-at-autoreleasepoolde-ce-shi-ji-shi-yong/)
	4. 手动加的Autorelease Pool，在使用结束时清空一次。
	5. 每次runloop迭代开始前系统自动创建Autorelease Pool，迭代结束时清空Autorelease Pool。
11. 类别覆盖类方法、类别方法重复定义
	1. [link1](http://tech.meituan.com/DiveIntoCategory.html)
	2. [link2](http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/)
	3. [link3](http://tech.meituan.com/DiveIntoCategory.html)
	4. 类别覆盖了原始类中已经实现的方法则没有任何办法再调用原始方法了。
		1. category的方法没有“完全替换掉”原来类已经有的方法，类的方法列表里会有两个method。
		2. category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，方法查找的时候是按方法列表顺序查找，找到之后就返回。
	5. 同一个类不同的类别实现了相同的方法则会使用最后一个编译的category的方法。
	6. category的load方法不会覆盖类的load的方法。
		1. load的方法跟普通方法一样会对主类覆盖。
		2. runtime调用load方法时是直接使用指针进行调用的。
		3. 手动给主类发送load消息实际上调用的是category中的load。
	7. category和extension的区别
		1. extension在编译期就确定，它是类的一部分，跟随类产生和消亡。
		2. extension用于隐藏类的私有消息，只有类的源码才能为类添加extension。
		3. category在运行时确定，所以category不能添加实例变量，因为在运行时对象的内存布局已经确定，添加实例变量会破坏类的内存布局。
12. 蓝牙
13. 堆和栈的区别
	1. 栈是一个用来存储局部和临时变量的存储空间。
		1. 一个线程会分配一个栈。
		2. 一个函数被调用，一个栈帧stack frame会被压到栈中。包括函数涉及到的参数、局部变量、返回地址等。
		3. 函数返回后，栈帧被销毁。
		4. iOS主线程分配栈空间1M，其他线程分配栈空间512K，OSX主线程分配栈空间8M。
		5. 栈中分配对象不太现实。
	2. 在堆上我们可以任何时候分配内存空间以及释放销毁它。
		1. 堆上必须显示的请求分配内存空间 malloc。
		2. 不用垃圾回收机制必须显示的释放它 free。
	3. Objective-C不支持创建栈对象。
	4. 对象是结构体，占一段连续的内存区域。
		1. 指向对象的指针存储在栈上。
		2. 对象存储在堆上。
	5. 栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。
		1. 如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。
		2. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
	6. [link1](http://kali.leanote.com/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Objective-C%E4%B8%AD%E5%8F%AA%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1)
	7. [link2](http://foggry.com/blog/2017/02/06/wei-shi-yao-objective-c-dui-xiang-cun-chu-zai-dui-shang-er-bu-shi-zhan-shang/)
	8. [link8](https://hit-alibaba.github.io/interview/basic/arch/Memory-Management.html#程序可执行文件的结构)

14. 应用安全
	1. 安全方案
	2. 安全评测
15. get/post区别

### 通用算法
1. [link1(查找)](http://www.cnblogs.com/Kobe10/p/6053131.html)
2. [link2(排序)](http://www.jcodecraeer.com/a/chengxusheji/shejimoshi/2015/0527/2941.html)

### 参考
1. [link1](https://mp.weixin.qq.com/s/lSg6EFcaSoVtlLcpfTBedA)
